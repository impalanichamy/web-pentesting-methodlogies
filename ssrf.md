SSRF- Server Side Request Forgery  
Types of SSRF:  
[Regular SSRF](https://github.com/impalanichamy/web-pentesting-methodlogies/blob/main/ssrf.md#RegularSSRF)   
[Blind SSRF](https://github.com/impalanichamy/web-pentesting-methodlogies/ssrf.md#Blind_SSRF)  


## RegularSSRF  
Description:

Server Side Request Forgery (SSRF) is a type of attack that can be carried out to compromise a server. The exploitation of a SSRF vulnerability enables attackers to send requests made by the web application, often targeting internal systems behind a firewall. Sometimes a server needs to make URL-request based on user input. A clear example would be an import-function, where you can import images from a URL, perhaps when setting a profile picture. When you as a user enter a URL, the server will make a request to that URL and fetch the image. 

What we can do with SSRF:
```
Scan the network for hosts,
Port scan internal machines and fingerprint internal services,
collect instance metadata,
bypass access controls,
leak confidential data,
and even execute code on reachable machines.
```

Port scan and Service Fingerprinting:  
```
We can use private IP address and loopback address for port scan [Reserved IP list](https://en.wikipedia.org/wiki/Reserved_IP_addresses)  
?url=10.0.0.1:80 --> Error: cannot upload image: http-server-header: Apache/2.2.8 (Ubuntu) DAV/2  
?url=10.0.0.1:11 --->  Error: cannot upload image: Connection Failed  
Check with [default port](https://packetlife.net/media/library/23/common-ports.pdf) and invalid ports.  
Means port 80 was open and port 11 is invalid. We can identify by server error message and response..    
```  
Bypass access controls:  
```  
Some internal services might only control access based on IP addresses or internal headers. It might be possible to bypass access controls to sensitive functionalities just by sending the request from a trusted machine.  
```  
Leak confidential information:  
```  
If you’re able to find credentials using the SSRF, you can then use those credentials to access confidential information stored on the network. For example, if you were able to find AWS S3 keys, go through the company’s private S3 buckets and see if you have access to those.  
```  
Execute code:  
```  
You can use the info you gathered to turn SSRF into RCE. For example, if you found admin credentials that give you write privileges, try uploading a shell. Or if you found an unsecured admin panel, are there any features that allow the execution of scripts? Better yet, maybe you can log in as root?  
```  
Leak aws meta data:
```
http://169.254.169.254/latest/meta-data/ returns the list of available metadata that you can query.
http://169.254.169.254/latest/meta-data/local-hostname/ returns the internal hostname used by the host.
http://169.254.169.254/latest/meta-data/iam/security-credentials/ROLE_NAME returns the security credentials of that role.
http://169.254.169.254/latest/dynamic/instance-identity/document reveals the private IP address of the current instance.
http://169.254.169.254/latest/user-data/ returns user data on the current instance. 
```

Leak Google cloud meta data:

Add following header if the request is processed properly


“Metadata-Flavor: Google” or “X-Google-Metadata-Request: True” 


```
http://metadata.google.internal/computeMetadata/v1beta1/instance/service-accounts/default/token returns the access token of the default account on the instance. 

http://metadata.google.internal/computeMetadata/v1beta1/project/attributes/ssh-key returns public SSH keys that can connect to other instances in this project. 
```

Other cloud meta data [link](https://gist.github.com/BuffaloWill/fa96693af67e3a3dd3fb)

## Blind_SSRF

Description:  
Blind SSRFs are SSRFs where you don’t get a response or error message back from the target server.
The exploitation of blind SSRFs is often limited to network mapping, port scanning, and service discovery. Since you can’t extract information directly from the target server, exploitation of blind SSRFs relies heavily on deduction. Utilizing HTTP status codes and server response times, we can achieve similar results as regular SSRF.


Network and Port Scanning using HTTP status codes:  
```  
For example, when you feed the following request results in an HTTP status code of 200 (Status code for “OK”).  
https://public.example.com/webhook?url=10.0.0.1  
While the following request results in an HTTP status code of 500 (Status code for “Internal Server Error”).  
https://public.example.com/webhook?url=10.0.0.2  
We can deduce that 10.0.0.1 is the address of a valid host on the network, while 10.0.0.2 is not.  
Port scanning with blind SSRF works the same way. If the server returns a 200 status code for some ports and 500 for others, the ports that yield a 200 status code might be the open ports on the machine.  
``` 

Network and Port Scanning using Server response times  
```  
![see below image for better understanding](https://miro.medium.com/max/875/1*Yo654ROcaYHbdM6HlPWjOQ.png)  

```  

